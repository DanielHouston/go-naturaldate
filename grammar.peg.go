package naturaldate

// Code generated by peg -inline -switch grammar.peg DO NOT EDIT

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"time"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleQuery
	ruleExpr
	ruleRelativeYear
	ruleRelativeMonth
	ruleDate
	ruleRelativeWeekdays
	ruleRelativeMinutes
	ruleRelativeHours
	ruleRelativeDays
	ruleRelativeWeeks
	ruleRelativeTime
	ruleRelative12Hour
	ruleRelative24Hour
	ruleMinutes
	ruleSeconds
	ruleNumber
	ruleWeekday
	ruleMonth
	ruleOrdinal
	ruleYEARS
	ruleMONTHS
	ruleWEEKS
	ruleDAYS
	ruleHOURS
	ruleMINUTES
	ruleYESTERDAY
	ruleTODAY
	ruleAGO
	ruleFROM_NOW
	ruleNOW
	ruleAM
	rulePM
	ruleAT
	ruleNEXT
	ruleLAST
	rule_
	ruleWhitespace
	ruleEOL
	ruleEOF
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	rulePegText
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
)

var rul3s = [...]string{
	"Unknown",
	"Query",
	"Expr",
	"RelativeYear",
	"RelativeMonth",
	"Date",
	"RelativeWeekdays",
	"RelativeMinutes",
	"RelativeHours",
	"RelativeDays",
	"RelativeWeeks",
	"RelativeTime",
	"Relative12Hour",
	"Relative24Hour",
	"Minutes",
	"Seconds",
	"Number",
	"Weekday",
	"Month",
	"Ordinal",
	"YEARS",
	"MONTHS",
	"WEEKS",
	"DAYS",
	"HOURS",
	"MINUTES",
	"YESTERDAY",
	"TODAY",
	"AGO",
	"FROM_NOW",
	"NOW",
	"AM",
	"PM",
	"AT",
	"NEXT",
	"LAST",
	"_",
	"Whitespace",
	"EOL",
	"EOF",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"PegText",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type parser struct {
	t         time.Time
	number    int
	month     time.Month
	weekday   time.Weekday
	direction int

	Buffer string
	buffer []rune
	rules  [99]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.t = truncateDay(p.t.AddDate(-p.number, 0, 0))

		case ruleAction1:

			p.t = truncateDay(p.t.AddDate(p.number, 0, 0))

		case ruleAction2:

			p.t = time.Date(p.t.Year()-1, 1, 1, 0, 0, 0, 0, p.t.Location())

		case ruleAction3:

			p.t = time.Date(p.t.Year()+1, 1, 1, 0, 0, 0, 0, p.t.Location())

		case ruleAction4:

			p.t = truncateDay(p.t.AddDate(0, -p.number, 0))

		case ruleAction5:

			p.t = truncateDay(p.t.AddDate(0, p.number, 0))

		case ruleAction6:

			p.t = prevMonth(p.t, p.month)

		case ruleAction7:

			p.t = nextMonth(p.t, p.month)

		case ruleAction8:

			if p.direction < 0 {
				p.t = prevMonth(p.t, p.month)
			} else {
				p.t = nextMonth(p.t, p.month)
			}

		case ruleAction9:

			year, month, _ := p.t.Date()
			p.t = time.Date(year, month, p.number, 0, 0, 0, 0, p.t.Location())

		case ruleAction10:

			p.t = truncateDay(p.t)

		case ruleAction11:

			p.t = truncateDay(p.t.Add(-day))

		case ruleAction12:

			p.t = truncateDay(prevWeekday(p.t, p.weekday))

		case ruleAction13:

			p.t = truncateDay(nextWeekday(p.t, p.weekday))

		case ruleAction14:

			if p.direction < 0 {
				p.t = truncateDay(prevWeekday(p.t, p.weekday))
			} else {
				p.t = truncateDay(nextWeekday(p.t, p.weekday))
			}

		case ruleAction15:

			p.t = p.t.Add(-time.Minute * time.Duration(p.number))

		case ruleAction16:

			p.t = p.t.Add(p.withDirection(time.Minute) * time.Duration(p.number))

		case ruleAction17:

			p.t = p.t.Add(-time.Hour * time.Duration(p.number))

		case ruleAction18:

			p.t = p.t.Add(p.withDirection(time.Hour) * time.Duration(p.number))

		case ruleAction19:

			p.t = truncateDay(p.t.Add(-day * time.Duration(p.number)))

		case ruleAction20:

			p.t = truncateDay(p.t.Add(p.withDirection(day) * time.Duration(p.number)))

		case ruleAction21:

			p.t = truncateDay(p.t.Add(-week * time.Duration(p.number)))

		case ruleAction22:

			p.t = truncateDay(p.t.Add(p.withDirection(week) * time.Duration(p.number)))

		case ruleAction23:

			year, month, day := p.t.Date()
			p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())

		case ruleAction24:

			year, month, day := p.t.Date()
			p.t = time.Date(year, month, day, p.number+12, 0, 0, 0, p.t.Location())

		case ruleAction25:

			year, month, day := p.t.Date()
			p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())

		case ruleAction26:

			t := p.t
			year, month, day := t.Date()
			hour, _, _ := t.Clock()
			p.t = time.Date(year, month, day, hour, p.number, 0, 0, t.Location())

		case ruleAction27:

			t := p.t
			year, month, day := t.Date()
			hour, min, _ := t.Clock()
			p.t = time.Date(year, month, day, hour, min, p.number, 0, t.Location())

		case ruleAction28:
			n, _ := strconv.Atoi(text)
			p.number = n
		case ruleAction29:
			p.number = 1
		case ruleAction30:
			p.number = 2
		case ruleAction31:
			p.number = 3
		case ruleAction32:
			p.number = 4
		case ruleAction33:
			p.number = 5
		case ruleAction34:
			p.number = 6
		case ruleAction35:
			p.number = 7
		case ruleAction36:
			p.number = 8
		case ruleAction37:
			p.number = 9
		case ruleAction38:
			p.number = 10
		case ruleAction39:
			p.weekday = time.Sunday
		case ruleAction40:
			p.weekday = time.Monday
		case ruleAction41:
			p.weekday = time.Tuesday
		case ruleAction42:
			p.weekday = time.Wednesday
		case ruleAction43:
			p.weekday = time.Thursday
		case ruleAction44:
			p.weekday = time.Friday
		case ruleAction45:
			p.weekday = time.Saturday
		case ruleAction46:
			p.month = time.January
		case ruleAction47:
			p.month = time.February
		case ruleAction48:
			p.month = time.March
		case ruleAction49:
			p.month = time.April
		case ruleAction50:
			p.month = time.May
		case ruleAction51:
			p.month = time.June
		case ruleAction52:
			p.month = time.July
		case ruleAction53:
			p.month = time.August
		case ruleAction54:
			p.month = time.September
		case ruleAction55:
			p.month = time.October
		case ruleAction56:
			p.month = time.November
		case ruleAction57:
			p.month = time.December

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*parser) error {
	return func(p *parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*parser) error {
	return func(p *parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *parser) Init(options ...func(*parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Query <- <(_ Expr _ EOF)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
				{
					position2 := position
					{
						position3, tokenIndex3 := position, tokenIndex
						{
							position5 := position
							if buffer[position] != rune('n') {
								goto l4
							}
							position++
							if buffer[position] != rune('o') {
								goto l4
							}
							position++
							if buffer[position] != rune('w') {
								goto l4
							}
							position++
							if !_rules[rule_]() {
								goto l4
							}
							add(ruleNOW, position5)
						}
						goto l3
					l4:
						position, tokenIndex = position3, tokenIndex3
						{
							position7 := position
							{
								position8, tokenIndex8 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l9
								}
								if !_rules[ruleMINUTES]() {
									goto l9
								}
								if !_rules[ruleAGO]() {
									goto l9
								}
								{
									add(ruleAction15, position)
								}
								goto l8
							l9:
								position, tokenIndex = position8, tokenIndex8
								if !_rules[ruleNumber]() {
									goto l6
								}
								if !_rules[ruleMINUTES]() {
									goto l6
								}
								{
									add(ruleAction16, position)
								}
							}
						l8:
							add(ruleRelativeMinutes, position7)
						}
						goto l3
					l6:
						position, tokenIndex = position3, tokenIndex3
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l15
								}
								if !_rules[ruleHOURS]() {
									goto l15
								}
								if !_rules[ruleAGO]() {
									goto l15
								}
								{
									add(ruleAction17, position)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								if !_rules[ruleNumber]() {
									goto l12
								}
								if !_rules[ruleHOURS]() {
									goto l12
								}
								{
									add(ruleAction18, position)
								}
							}
						l14:
							add(ruleRelativeHours, position13)
						}
						goto l3
					l12:
						position, tokenIndex = position3, tokenIndex3
						{
							position19 := position
							{
								position20, tokenIndex20 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l21
								}
								if !_rules[ruleDAYS]() {
									goto l21
								}
								if !_rules[ruleAGO]() {
									goto l21
								}
								{
									add(ruleAction19, position)
								}
								goto l20
							l21:
								position, tokenIndex = position20, tokenIndex20
								if !_rules[ruleNumber]() {
									goto l18
								}
								if !_rules[ruleDAYS]() {
									goto l18
								}
								{
									add(ruleAction20, position)
								}
							}
						l20:
							add(ruleRelativeDays, position19)
						}
						goto l3
					l18:
						position, tokenIndex = position3, tokenIndex3
						{
							position25 := position
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l27
								}
								if !_rules[ruleWEEKS]() {
									goto l27
								}
								if !_rules[ruleAGO]() {
									goto l27
								}
								{
									add(ruleAction21, position)
								}
								goto l26
							l27:
								position, tokenIndex = position26, tokenIndex26
								if !_rules[ruleNumber]() {
									goto l24
								}
								if !_rules[ruleWEEKS]() {
									goto l24
								}
								{
									add(ruleAction22, position)
								}
							}
						l26:
							add(ruleRelativeWeeks, position25)
						}
						goto l3
					l24:
						position, tokenIndex = position3, tokenIndex3
						{
							position31 := position
							{
								position32, tokenIndex32 := position, tokenIndex
								{
									position34 := position
									if buffer[position] != rune('t') {
										goto l33
									}
									position++
									if buffer[position] != rune('o') {
										goto l33
									}
									position++
									if buffer[position] != rune('d') {
										goto l33
									}
									position++
									if buffer[position] != rune('a') {
										goto l33
									}
									position++
									if buffer[position] != rune('y') {
										goto l33
									}
									position++
									if !_rules[rule_]() {
										goto l33
									}
									add(ruleTODAY, position34)
								}
								{
									add(ruleAction10, position)
								}
								goto l32
							l33:
								position, tokenIndex = position32, tokenIndex32
								{
									switch buffer[position] {
									case 'n':
										if !_rules[ruleNEXT]() {
											goto l30
										}
										if !_rules[ruleWeekday]() {
											goto l30
										}
										{
											add(ruleAction13, position)
										}
										break
									case 'y':
										{
											position38 := position
											if buffer[position] != rune('y') {
												goto l30
											}
											position++
											if buffer[position] != rune('e') {
												goto l30
											}
											position++
											if buffer[position] != rune('s') {
												goto l30
											}
											position++
											if buffer[position] != rune('t') {
												goto l30
											}
											position++
											if buffer[position] != rune('e') {
												goto l30
											}
											position++
											if buffer[position] != rune('r') {
												goto l30
											}
											position++
											if buffer[position] != rune('d') {
												goto l30
											}
											position++
											if buffer[position] != rune('a') {
												goto l30
											}
											position++
											if buffer[position] != rune('y') {
												goto l30
											}
											position++
											if !_rules[rule_]() {
												goto l30
											}
											add(ruleYESTERDAY, position38)
										}
										{
											add(ruleAction11, position)
										}
										break
									case 'l', 'p':
										if !_rules[ruleLAST]() {
											goto l30
										}
										if !_rules[ruleWeekday]() {
											goto l30
										}
										{
											add(ruleAction12, position)
										}
										break
									default:
										if !_rules[ruleWeekday]() {
											goto l30
										}
										{
											add(ruleAction14, position)
										}
										break
									}
								}

							}
						l32:
							add(ruleRelativeWeekdays, position31)
						}
						{
							position42, tokenIndex42 := position, tokenIndex
							{
								position44, tokenIndex44 := position, tokenIndex
								if !_rules[ruleAT]() {
									goto l44
								}
								goto l45
							l44:
								position, tokenIndex = position44, tokenIndex44
							}
						l45:
							if !_rules[ruleRelativeTime]() {
								goto l42
							}
							goto l43
						l42:
							position, tokenIndex = position42, tokenIndex42
						}
					l43:
						goto l3
					l30:
						position, tokenIndex = position3, tokenIndex3
						{
							position47 := position
							{
								position48, tokenIndex48 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l49
								}
								if !_rules[ruleMONTHS]() {
									goto l49
								}
								if !_rules[ruleAGO]() {
									goto l49
								}
								{
									add(ruleAction4, position)
								}
								goto l48
							l49:
								position, tokenIndex = position48, tokenIndex48
								if !_rules[ruleNumber]() {
									goto l51
								}
								if !_rules[ruleMONTHS]() {
									goto l51
								}
								if !_rules[ruleFROM_NOW]() {
									goto l51
								}
								{
									add(ruleAction5, position)
								}
								goto l48
							l51:
								position, tokenIndex = position48, tokenIndex48
								if !_rules[ruleLAST]() {
									goto l53
								}
								if !_rules[ruleMonth]() {
									goto l53
								}
								{
									add(ruleAction6, position)
								}
								goto l48
							l53:
								position, tokenIndex = position48, tokenIndex48
								if !_rules[ruleNEXT]() {
									goto l55
								}
								if !_rules[ruleMonth]() {
									goto l55
								}
								{
									add(ruleAction7, position)
								}
								goto l48
							l55:
								position, tokenIndex = position48, tokenIndex48
								if !_rules[ruleMonth]() {
									goto l46
								}
								{
									add(ruleAction8, position)
								}
							}
						l48:
							add(ruleRelativeMonth, position47)
						}
						{
							position58, tokenIndex58 := position, tokenIndex
							{
								position60 := position
								{
									position61, tokenIndex61 := position, tokenIndex
									if !_rules[ruleNumber]() {
										goto l61
									}
									{
										position63, tokenIndex63 := position, tokenIndex
										{
											position65 := position
											{
												switch buffer[position] {
												case 't':
													if buffer[position] != rune('t') {
														goto l63
													}
													position++
													if buffer[position] != rune('h') {
														goto l63
													}
													position++
													if !_rules[rule_]() {
														goto l63
													}
													break
												case 'r':
													if buffer[position] != rune('r') {
														goto l63
													}
													position++
													if buffer[position] != rune('d') {
														goto l63
													}
													position++
													if !_rules[rule_]() {
														goto l63
													}
													break
												case 'n':
													if buffer[position] != rune('n') {
														goto l63
													}
													position++
													if buffer[position] != rune('d') {
														goto l63
													}
													position++
													if !_rules[rule_]() {
														goto l63
													}
													break
												default:
													if buffer[position] != rune('s') {
														goto l63
													}
													position++
													if buffer[position] != rune('t') {
														goto l63
													}
													position++
													if !_rules[rule_]() {
														goto l63
													}
													break
												}
											}

											add(ruleOrdinal, position65)
										}
										goto l64
									l63:
										position, tokenIndex = position63, tokenIndex63
									}
								l64:
									{
										add(ruleAction9, position)
									}
									goto l62
								l61:
									position, tokenIndex = position61, tokenIndex61
								}
							l62:
								add(ruleDate, position60)
							}
							goto l59

							position, tokenIndex = position58, tokenIndex58
						}
					l59:
						{
							position68, tokenIndex68 := position, tokenIndex
							{
								position70, tokenIndex70 := position, tokenIndex
								if !_rules[ruleAT]() {
									goto l70
								}
								goto l71
							l70:
								position, tokenIndex = position70, tokenIndex70
							}
						l71:
							if !_rules[ruleRelativeTime]() {
								goto l68
							}
							goto l69
						l68:
							position, tokenIndex = position68, tokenIndex68
						}
					l69:
						goto l3
					l46:
						position, tokenIndex = position3, tokenIndex3
						{
							position73 := position
							{
								position74, tokenIndex74 := position, tokenIndex
								if !_rules[ruleNumber]() {
									goto l75
								}
								if !_rules[ruleYEARS]() {
									goto l75
								}
								if !_rules[ruleAGO]() {
									goto l75
								}
								{
									add(ruleAction0, position)
								}
								goto l74
							l75:
								position, tokenIndex = position74, tokenIndex74
								if !_rules[ruleNumber]() {
									goto l77
								}
								if !_rules[ruleYEARS]() {
									goto l77
								}
								if !_rules[ruleFROM_NOW]() {
									goto l77
								}
								{
									add(ruleAction1, position)
								}
								goto l74
							l77:
								position, tokenIndex = position74, tokenIndex74
								if !_rules[ruleLAST]() {
									goto l79
								}
								if !_rules[ruleYEARS]() {
									goto l79
								}
								{
									add(ruleAction2, position)
								}
								goto l74
							l79:
								position, tokenIndex = position74, tokenIndex74
								if !_rules[ruleNEXT]() {
									goto l72
								}
								if !_rules[ruleYEARS]() {
									goto l72
								}
								{
									add(ruleAction3, position)
								}
							}
						l74:
							add(ruleRelativeYear, position73)
						}
						goto l3
					l72:
						position, tokenIndex = position3, tokenIndex3
						if !_rules[ruleRelativeTime]() {
							goto l0
						}
					}
				l3:
					add(ruleExpr, position2)
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position82 := position
					{
						position83, tokenIndex83 := position, tokenIndex
						if !matchDot() {
							goto l83
						}
						goto l0
					l83:
						position, tokenIndex = position83, tokenIndex83
					}
					add(ruleEOF, position82)
				}
				add(ruleQuery, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expr <- <(NOW / RelativeMinutes / RelativeHours / RelativeDays / RelativeWeeks / (RelativeWeekdays (AT? RelativeTime)?) / (RelativeMonth Date? (AT? RelativeTime)?) / RelativeYear / RelativeTime)> */
		nil,
		/* 2 RelativeYear <- <((Number YEARS AGO Action0) / (Number YEARS FROM_NOW Action1) / (LAST YEARS Action2) / (NEXT YEARS Action3))> */
		nil,
		/* 3 RelativeMonth <- <((Number MONTHS AGO Action4) / (Number MONTHS FROM_NOW Action5) / (LAST Month Action6) / (NEXT Month Action7) / (Month Action8))> */
		nil,
		/* 4 Date <- <(Number Ordinal? Action9)?> */
		nil,
		/* 5 RelativeWeekdays <- <((TODAY Action10) / ((&('n') (NEXT Weekday Action13)) | (&('y') (YESTERDAY Action11)) | (&('l' | 'p') (LAST Weekday Action12)) | (&('f' | 'm' | 's' | 't' | 'w') (Weekday Action14))))> */
		nil,
		/* 6 RelativeMinutes <- <((Number MINUTES AGO Action15) / (Number MINUTES Action16))> */
		nil,
		/* 7 RelativeHours <- <((Number HOURS AGO Action17) / (Number HOURS Action18))> */
		nil,
		/* 8 RelativeDays <- <((Number DAYS AGO Action19) / (Number DAYS Action20))> */
		nil,
		/* 9 RelativeWeeks <- <((Number WEEKS AGO Action21) / (Number WEEKS Action22))> */
		nil,
		/* 10 RelativeTime <- <(Relative12Hour / Relative24Hour)> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				{
					position95, tokenIndex95 := position, tokenIndex
					{
						position97 := position
						{
							position98, tokenIndex98 := position, tokenIndex
							if !_rules[ruleNumber]() {
								goto l99
							}
							{
								add(ruleAction23, position)
							}
							{
								position101, tokenIndex101 := position, tokenIndex
								if !_rules[ruleMinutes]() {
									goto l101
								}
								{
									position103, tokenIndex103 := position, tokenIndex
									if !_rules[ruleSeconds]() {
										goto l103
									}
									goto l104
								l103:
									position, tokenIndex = position103, tokenIndex103
								}
							l104:
								goto l102
							l101:
								position, tokenIndex = position101, tokenIndex101
							}
						l102:
							{
								position105 := position
								if buffer[position] != rune('a') {
									goto l99
								}
								position++
								if buffer[position] != rune('m') {
									goto l99
								}
								position++
								if !_rules[rule_]() {
									goto l99
								}
								add(ruleAM, position105)
							}
							goto l98
						l99:
							position, tokenIndex = position98, tokenIndex98
							if !_rules[ruleNumber]() {
								goto l96
							}
							{
								add(ruleAction24, position)
							}
							{
								position107, tokenIndex107 := position, tokenIndex
								if !_rules[ruleMinutes]() {
									goto l107
								}
								{
									position109, tokenIndex109 := position, tokenIndex
									if !_rules[ruleSeconds]() {
										goto l109
									}
									goto l110
								l109:
									position, tokenIndex = position109, tokenIndex109
								}
							l110:
								goto l108
							l107:
								position, tokenIndex = position107, tokenIndex107
							}
						l108:
							{
								position111 := position
								if buffer[position] != rune('p') {
									goto l96
								}
								position++
								if buffer[position] != rune('m') {
									goto l96
								}
								position++
								if !_rules[rule_]() {
									goto l96
								}
								add(rulePM, position111)
							}
						}
					l98:
						add(ruleRelative12Hour, position97)
					}
					goto l95
				l96:
					position, tokenIndex = position95, tokenIndex95
					{
						position112 := position
						if !_rules[ruleNumber]() {
							goto l93
						}
						{
							add(ruleAction25, position)
						}
						{
							position114, tokenIndex114 := position, tokenIndex
							if !_rules[ruleMinutes]() {
								goto l114
							}
							{
								position116, tokenIndex116 := position, tokenIndex
								if !_rules[ruleSeconds]() {
									goto l116
								}
								goto l117
							l116:
								position, tokenIndex = position116, tokenIndex116
							}
						l117:
							goto l115
						l114:
							position, tokenIndex = position114, tokenIndex114
						}
					l115:
						add(ruleRelative24Hour, position112)
					}
				}
			l95:
				add(ruleRelativeTime, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 11 Relative12Hour <- <((Number Action23 (Minutes Seconds?)? AM) / (Number Action24 (Minutes Seconds?)? PM))> */
		nil,
		/* 12 Relative24Hour <- <(Number Action25 (Minutes Seconds?)?)> */
		nil,
		/* 13 Minutes <- <(':' Number Action26)> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				if buffer[position] != rune(':') {
					goto l120
				}
				position++
				if !_rules[ruleNumber]() {
					goto l120
				}
				{
					add(ruleAction26, position)
				}
				add(ruleMinutes, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 14 Seconds <- <(':' Number Action27)> */
		func() bool {
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				if buffer[position] != rune(':') {
					goto l123
				}
				position++
				if !_rules[ruleNumber]() {
					goto l123
				}
				{
					add(ruleAction27, position)
				}
				add(ruleSeconds, position124)
			}
			return true
		l123:
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 15 Number <- <(('t' 'w' 'o' _ Action30) / ('t' 'h' 'r' 'e' 'e' _ Action31) / ('f' 'o' 'u' 'r' _ Action32) / ('s' 'i' 'x' _ Action34) / ((&('t') ('t' 'e' 'n' _ Action38)) | (&('n') ('n' 'i' 'n' 'e' _ Action37)) | (&('e') ('e' 'i' 'g' 'h' 't' _ Action36)) | (&('s') ('s' 'e' 'v' 'e' 'n' _ Action35)) | (&('f') ('f' 'i' 'v' 'e' _ Action33)) | (&('o') ('o' 'n' 'e' _ Action29)) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<[0-9]+> _ Action28))))> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				{
					position128, tokenIndex128 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l129
					}
					position++
					if buffer[position] != rune('w') {
						goto l129
					}
					position++
					if buffer[position] != rune('o') {
						goto l129
					}
					position++
					if !_rules[rule_]() {
						goto l129
					}
					{
						add(ruleAction30, position)
					}
					goto l128
				l129:
					position, tokenIndex = position128, tokenIndex128
					if buffer[position] != rune('t') {
						goto l131
					}
					position++
					if buffer[position] != rune('h') {
						goto l131
					}
					position++
					if buffer[position] != rune('r') {
						goto l131
					}
					position++
					if buffer[position] != rune('e') {
						goto l131
					}
					position++
					if buffer[position] != rune('e') {
						goto l131
					}
					position++
					if !_rules[rule_]() {
						goto l131
					}
					{
						add(ruleAction31, position)
					}
					goto l128
				l131:
					position, tokenIndex = position128, tokenIndex128
					if buffer[position] != rune('f') {
						goto l133
					}
					position++
					if buffer[position] != rune('o') {
						goto l133
					}
					position++
					if buffer[position] != rune('u') {
						goto l133
					}
					position++
					if buffer[position] != rune('r') {
						goto l133
					}
					position++
					if !_rules[rule_]() {
						goto l133
					}
					{
						add(ruleAction32, position)
					}
					goto l128
				l133:
					position, tokenIndex = position128, tokenIndex128
					if buffer[position] != rune('s') {
						goto l135
					}
					position++
					if buffer[position] != rune('i') {
						goto l135
					}
					position++
					if buffer[position] != rune('x') {
						goto l135
					}
					position++
					if !_rules[rule_]() {
						goto l135
					}
					{
						add(ruleAction34, position)
					}
					goto l128
				l135:
					position, tokenIndex = position128, tokenIndex128
					{
						switch buffer[position] {
						case 't':
							if buffer[position] != rune('t') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if buffer[position] != rune('n') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction38, position)
							}
							break
						case 'n':
							if buffer[position] != rune('n') {
								goto l126
							}
							position++
							if buffer[position] != rune('i') {
								goto l126
							}
							position++
							if buffer[position] != rune('n') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction37, position)
							}
							break
						case 'e':
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if buffer[position] != rune('i') {
								goto l126
							}
							position++
							if buffer[position] != rune('g') {
								goto l126
							}
							position++
							if buffer[position] != rune('h') {
								goto l126
							}
							position++
							if buffer[position] != rune('t') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction36, position)
							}
							break
						case 's':
							if buffer[position] != rune('s') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if buffer[position] != rune('v') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if buffer[position] != rune('n') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction35, position)
							}
							break
						case 'f':
							if buffer[position] != rune('f') {
								goto l126
							}
							position++
							if buffer[position] != rune('i') {
								goto l126
							}
							position++
							if buffer[position] != rune('v') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction33, position)
							}
							break
						case 'o':
							if buffer[position] != rune('o') {
								goto l126
							}
							position++
							if buffer[position] != rune('n') {
								goto l126
							}
							position++
							if buffer[position] != rune('e') {
								goto l126
							}
							position++
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction29, position)
							}
							break
						default:
							{
								position144 := position
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l126
								}
								position++
							l145:
								{
									position146, tokenIndex146 := position, tokenIndex
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l146
									}
									position++
									goto l145
								l146:
									position, tokenIndex = position146, tokenIndex146
								}
								add(rulePegText, position144)
							}
							if !_rules[rule_]() {
								goto l126
							}
							{
								add(ruleAction28, position)
							}
							break
						}
					}

				}
			l128:
				add(ruleNumber, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 16 Weekday <- <(('s' 'u' 'n' 'd' 'a' 'y' _ Action39) / ('t' 'u' 'e' 's' 'd' 'a' 'y' _ Action41) / ((&('s') ('s' 'a' 't' 'u' 'r' 'd' 'a' 'y' _ Action45)) | (&('f') ('f' 'r' 'i' 'd' 'a' 'y' _ Action44)) | (&('t') ('t' 'h' 'u' 'r' 's' 'd' 'a' 'y' _ Action43)) | (&('w') ('w' 'e' 'd' 'n' 'e' 's' 'd' 'a' 'y' _ Action42)) | (&('m') ('m' 'o' 'n' 'd' 'a' 'y' _ Action40))))> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				{
					position150, tokenIndex150 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l151
					}
					position++
					if buffer[position] != rune('u') {
						goto l151
					}
					position++
					if buffer[position] != rune('n') {
						goto l151
					}
					position++
					if buffer[position] != rune('d') {
						goto l151
					}
					position++
					if buffer[position] != rune('a') {
						goto l151
					}
					position++
					if buffer[position] != rune('y') {
						goto l151
					}
					position++
					if !_rules[rule_]() {
						goto l151
					}
					{
						add(ruleAction39, position)
					}
					goto l150
				l151:
					position, tokenIndex = position150, tokenIndex150
					if buffer[position] != rune('t') {
						goto l153
					}
					position++
					if buffer[position] != rune('u') {
						goto l153
					}
					position++
					if buffer[position] != rune('e') {
						goto l153
					}
					position++
					if buffer[position] != rune('s') {
						goto l153
					}
					position++
					if buffer[position] != rune('d') {
						goto l153
					}
					position++
					if buffer[position] != rune('a') {
						goto l153
					}
					position++
					if buffer[position] != rune('y') {
						goto l153
					}
					position++
					if !_rules[rule_]() {
						goto l153
					}
					{
						add(ruleAction41, position)
					}
					goto l150
				l153:
					position, tokenIndex = position150, tokenIndex150
					{
						switch buffer[position] {
						case 's':
							if buffer[position] != rune('s') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('t') {
								goto l148
							}
							position++
							if buffer[position] != rune('u') {
								goto l148
							}
							position++
							if buffer[position] != rune('r') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('y') {
								goto l148
							}
							position++
							if !_rules[rule_]() {
								goto l148
							}
							{
								add(ruleAction45, position)
							}
							break
						case 'f':
							if buffer[position] != rune('f') {
								goto l148
							}
							position++
							if buffer[position] != rune('r') {
								goto l148
							}
							position++
							if buffer[position] != rune('i') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('y') {
								goto l148
							}
							position++
							if !_rules[rule_]() {
								goto l148
							}
							{
								add(ruleAction44, position)
							}
							break
						case 't':
							if buffer[position] != rune('t') {
								goto l148
							}
							position++
							if buffer[position] != rune('h') {
								goto l148
							}
							position++
							if buffer[position] != rune('u') {
								goto l148
							}
							position++
							if buffer[position] != rune('r') {
								goto l148
							}
							position++
							if buffer[position] != rune('s') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('y') {
								goto l148
							}
							position++
							if !_rules[rule_]() {
								goto l148
							}
							{
								add(ruleAction43, position)
							}
							break
						case 'w':
							if buffer[position] != rune('w') {
								goto l148
							}
							position++
							if buffer[position] != rune('e') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('n') {
								goto l148
							}
							position++
							if buffer[position] != rune('e') {
								goto l148
							}
							position++
							if buffer[position] != rune('s') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('y') {
								goto l148
							}
							position++
							if !_rules[rule_]() {
								goto l148
							}
							{
								add(ruleAction42, position)
							}
							break
						default:
							if buffer[position] != rune('m') {
								goto l148
							}
							position++
							if buffer[position] != rune('o') {
								goto l148
							}
							position++
							if buffer[position] != rune('n') {
								goto l148
							}
							position++
							if buffer[position] != rune('d') {
								goto l148
							}
							position++
							if buffer[position] != rune('a') {
								goto l148
							}
							position++
							if buffer[position] != rune('y') {
								goto l148
							}
							position++
							if !_rules[rule_]() {
								goto l148
							}
							{
								add(ruleAction40, position)
							}
							break
						}
					}

				}
			l150:
				add(ruleWeekday, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 17 Month <- <(('j' 'a' 'n' 'u' 'a' 'r' 'y' _ Action46) / ('m' 'a' 'r' 'c' 'h' _ Action48) / ('a' 'p' 'r' 'i' 'l' _ Action49) / ('j' 'u' 'n' 'e' _ Action51) / ((&('d') ('d' 'e' 'c' 'e' 'm' 'b' 'e' 'r' _ Action57)) | (&('n') ('n' 'o' 'v' 'e' 'm' 'b' 'e' 'r' _ Action56)) | (&('o') ('o' 'c' 't' 'o' 'b' 'e' 'r' _ Action55)) | (&('s') ('s' 'e' 'p' 't' 'e' 'm' 'b' 'e' 'r' _ Action54)) | (&('a') ('a' 'u' 'g' 'u' 's' 't' _ Action53)) | (&('j') ('j' 'u' 'l' 'y' _ Action52)) | (&('m') ('m' 'a' 'y' _ Action50)) | (&('f') ('f' 'e' 'b' 'r' 'u' 'a' 'r' 'y' _ Action47))))> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				{
					position163, tokenIndex163 := position, tokenIndex
					if buffer[position] != rune('j') {
						goto l164
					}
					position++
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('n') {
						goto l164
					}
					position++
					if buffer[position] != rune('u') {
						goto l164
					}
					position++
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('r') {
						goto l164
					}
					position++
					if buffer[position] != rune('y') {
						goto l164
					}
					position++
					if !_rules[rule_]() {
						goto l164
					}
					{
						add(ruleAction46, position)
					}
					goto l163
				l164:
					position, tokenIndex = position163, tokenIndex163
					if buffer[position] != rune('m') {
						goto l166
					}
					position++
					if buffer[position] != rune('a') {
						goto l166
					}
					position++
					if buffer[position] != rune('r') {
						goto l166
					}
					position++
					if buffer[position] != rune('c') {
						goto l166
					}
					position++
					if buffer[position] != rune('h') {
						goto l166
					}
					position++
					if !_rules[rule_]() {
						goto l166
					}
					{
						add(ruleAction48, position)
					}
					goto l163
				l166:
					position, tokenIndex = position163, tokenIndex163
					if buffer[position] != rune('a') {
						goto l168
					}
					position++
					if buffer[position] != rune('p') {
						goto l168
					}
					position++
					if buffer[position] != rune('r') {
						goto l168
					}
					position++
					if buffer[position] != rune('i') {
						goto l168
					}
					position++
					if buffer[position] != rune('l') {
						goto l168
					}
					position++
					if !_rules[rule_]() {
						goto l168
					}
					{
						add(ruleAction49, position)
					}
					goto l163
				l168:
					position, tokenIndex = position163, tokenIndex163
					if buffer[position] != rune('j') {
						goto l170
					}
					position++
					if buffer[position] != rune('u') {
						goto l170
					}
					position++
					if buffer[position] != rune('n') {
						goto l170
					}
					position++
					if buffer[position] != rune('e') {
						goto l170
					}
					position++
					if !_rules[rule_]() {
						goto l170
					}
					{
						add(ruleAction51, position)
					}
					goto l163
				l170:
					position, tokenIndex = position163, tokenIndex163
					{
						switch buffer[position] {
						case 'd':
							if buffer[position] != rune('d') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('c') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('m') {
								goto l161
							}
							position++
							if buffer[position] != rune('b') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction57, position)
							}
							break
						case 'n':
							if buffer[position] != rune('n') {
								goto l161
							}
							position++
							if buffer[position] != rune('o') {
								goto l161
							}
							position++
							if buffer[position] != rune('v') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('m') {
								goto l161
							}
							position++
							if buffer[position] != rune('b') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction56, position)
							}
							break
						case 'o':
							if buffer[position] != rune('o') {
								goto l161
							}
							position++
							if buffer[position] != rune('c') {
								goto l161
							}
							position++
							if buffer[position] != rune('t') {
								goto l161
							}
							position++
							if buffer[position] != rune('o') {
								goto l161
							}
							position++
							if buffer[position] != rune('b') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction55, position)
							}
							break
						case 's':
							if buffer[position] != rune('s') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('p') {
								goto l161
							}
							position++
							if buffer[position] != rune('t') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('m') {
								goto l161
							}
							position++
							if buffer[position] != rune('b') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction54, position)
							}
							break
						case 'a':
							if buffer[position] != rune('a') {
								goto l161
							}
							position++
							if buffer[position] != rune('u') {
								goto l161
							}
							position++
							if buffer[position] != rune('g') {
								goto l161
							}
							position++
							if buffer[position] != rune('u') {
								goto l161
							}
							position++
							if buffer[position] != rune('s') {
								goto l161
							}
							position++
							if buffer[position] != rune('t') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction53, position)
							}
							break
						case 'j':
							if buffer[position] != rune('j') {
								goto l161
							}
							position++
							if buffer[position] != rune('u') {
								goto l161
							}
							position++
							if buffer[position] != rune('l') {
								goto l161
							}
							position++
							if buffer[position] != rune('y') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction52, position)
							}
							break
						case 'm':
							if buffer[position] != rune('m') {
								goto l161
							}
							position++
							if buffer[position] != rune('a') {
								goto l161
							}
							position++
							if buffer[position] != rune('y') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction50, position)
							}
							break
						default:
							if buffer[position] != rune('f') {
								goto l161
							}
							position++
							if buffer[position] != rune('e') {
								goto l161
							}
							position++
							if buffer[position] != rune('b') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if buffer[position] != rune('u') {
								goto l161
							}
							position++
							if buffer[position] != rune('a') {
								goto l161
							}
							position++
							if buffer[position] != rune('r') {
								goto l161
							}
							position++
							if buffer[position] != rune('y') {
								goto l161
							}
							position++
							if !_rules[rule_]() {
								goto l161
							}
							{
								add(ruleAction47, position)
							}
							break
						}
					}

				}
			l163:
				add(ruleMonth, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 18 Ordinal <- <((&('t') ('t' 'h' _)) | (&('r') ('r' 'd' _)) | (&('n') ('n' 'd' _)) | (&('s') ('s' 't' _)))> */
		nil,
		/* 19 YEARS <- <('y' 'e' 'a' 'r' 's'? _)> */
		func() bool {
			position182, tokenIndex182 := position, tokenIndex
			{
				position183 := position
				if buffer[position] != rune('y') {
					goto l182
				}
				position++
				if buffer[position] != rune('e') {
					goto l182
				}
				position++
				if buffer[position] != rune('a') {
					goto l182
				}
				position++
				if buffer[position] != rune('r') {
					goto l182
				}
				position++
				{
					position184, tokenIndex184 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l184
					}
					position++
					goto l185
				l184:
					position, tokenIndex = position184, tokenIndex184
				}
			l185:
				if !_rules[rule_]() {
					goto l182
				}
				add(ruleYEARS, position183)
			}
			return true
		l182:
			position, tokenIndex = position182, tokenIndex182
			return false
		},
		/* 20 MONTHS <- <('m' 'o' 'n' 't' 'h' 's'? _)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				if buffer[position] != rune('m') {
					goto l186
				}
				position++
				if buffer[position] != rune('o') {
					goto l186
				}
				position++
				if buffer[position] != rune('n') {
					goto l186
				}
				position++
				if buffer[position] != rune('t') {
					goto l186
				}
				position++
				if buffer[position] != rune('h') {
					goto l186
				}
				position++
				{
					position188, tokenIndex188 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l188
					}
					position++
					goto l189
				l188:
					position, tokenIndex = position188, tokenIndex188
				}
			l189:
				if !_rules[rule_]() {
					goto l186
				}
				add(ruleMONTHS, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 21 WEEKS <- <('w' 'e' 'e' 'k' 's'? _)> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if buffer[position] != rune('w') {
					goto l190
				}
				position++
				if buffer[position] != rune('e') {
					goto l190
				}
				position++
				if buffer[position] != rune('e') {
					goto l190
				}
				position++
				if buffer[position] != rune('k') {
					goto l190
				}
				position++
				{
					position192, tokenIndex192 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l192
					}
					position++
					goto l193
				l192:
					position, tokenIndex = position192, tokenIndex192
				}
			l193:
				if !_rules[rule_]() {
					goto l190
				}
				add(ruleWEEKS, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 22 DAYS <- <('d' 'a' 'y' 's'? _)> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				if buffer[position] != rune('d') {
					goto l194
				}
				position++
				if buffer[position] != rune('a') {
					goto l194
				}
				position++
				if buffer[position] != rune('y') {
					goto l194
				}
				position++
				{
					position196, tokenIndex196 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l196
					}
					position++
					goto l197
				l196:
					position, tokenIndex = position196, tokenIndex196
				}
			l197:
				if !_rules[rule_]() {
					goto l194
				}
				add(ruleDAYS, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 23 HOURS <- <('h' 'o' 'u' 'r' 's'? _)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if buffer[position] != rune('h') {
					goto l198
				}
				position++
				if buffer[position] != rune('o') {
					goto l198
				}
				position++
				if buffer[position] != rune('u') {
					goto l198
				}
				position++
				if buffer[position] != rune('r') {
					goto l198
				}
				position++
				{
					position200, tokenIndex200 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l200
					}
					position++
					goto l201
				l200:
					position, tokenIndex = position200, tokenIndex200
				}
			l201:
				if !_rules[rule_]() {
					goto l198
				}
				add(ruleHOURS, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 24 MINUTES <- <('m' 'i' 'n' 'u' 't' 'e' 's'? _)> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if buffer[position] != rune('m') {
					goto l202
				}
				position++
				if buffer[position] != rune('i') {
					goto l202
				}
				position++
				if buffer[position] != rune('n') {
					goto l202
				}
				position++
				if buffer[position] != rune('u') {
					goto l202
				}
				position++
				if buffer[position] != rune('t') {
					goto l202
				}
				position++
				if buffer[position] != rune('e') {
					goto l202
				}
				position++
				{
					position204, tokenIndex204 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l204
					}
					position++
					goto l205
				l204:
					position, tokenIndex = position204, tokenIndex204
				}
			l205:
				if !_rules[rule_]() {
					goto l202
				}
				add(ruleMINUTES, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 25 YESTERDAY <- <('y' 'e' 's' 't' 'e' 'r' 'd' 'a' 'y' _)> */
		nil,
		/* 26 TODAY <- <('t' 'o' 'd' 'a' 'y' _)> */
		nil,
		/* 27 AGO <- <('a' 'g' 'o' _)> */
		func() bool {
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				if buffer[position] != rune('a') {
					goto l208
				}
				position++
				if buffer[position] != rune('g') {
					goto l208
				}
				position++
				if buffer[position] != rune('o') {
					goto l208
				}
				position++
				if !_rules[rule_]() {
					goto l208
				}
				add(ruleAGO, position209)
			}
			return true
		l208:
			position, tokenIndex = position208, tokenIndex208
			return false
		},
		/* 28 FROM_NOW <- <((('f' 'r' 'o' 'm' ' ' 'n' 'o' 'w') / ('f' 'r' 'o' 'm' ' ' 't' 'o' 'd' 'a' 'y')) _)> */
		func() bool {
			position210, tokenIndex210 := position, tokenIndex
			{
				position211 := position
				{
					position212, tokenIndex212 := position, tokenIndex
					if buffer[position] != rune('f') {
						goto l213
					}
					position++
					if buffer[position] != rune('r') {
						goto l213
					}
					position++
					if buffer[position] != rune('o') {
						goto l213
					}
					position++
					if buffer[position] != rune('m') {
						goto l213
					}
					position++
					if buffer[position] != rune(' ') {
						goto l213
					}
					position++
					if buffer[position] != rune('n') {
						goto l213
					}
					position++
					if buffer[position] != rune('o') {
						goto l213
					}
					position++
					if buffer[position] != rune('w') {
						goto l213
					}
					position++
					goto l212
				l213:
					position, tokenIndex = position212, tokenIndex212
					if buffer[position] != rune('f') {
						goto l210
					}
					position++
					if buffer[position] != rune('r') {
						goto l210
					}
					position++
					if buffer[position] != rune('o') {
						goto l210
					}
					position++
					if buffer[position] != rune('m') {
						goto l210
					}
					position++
					if buffer[position] != rune(' ') {
						goto l210
					}
					position++
					if buffer[position] != rune('t') {
						goto l210
					}
					position++
					if buffer[position] != rune('o') {
						goto l210
					}
					position++
					if buffer[position] != rune('d') {
						goto l210
					}
					position++
					if buffer[position] != rune('a') {
						goto l210
					}
					position++
					if buffer[position] != rune('y') {
						goto l210
					}
					position++
				}
			l212:
				if !_rules[rule_]() {
					goto l210
				}
				add(ruleFROM_NOW, position211)
			}
			return true
		l210:
			position, tokenIndex = position210, tokenIndex210
			return false
		},
		/* 29 NOW <- <('n' 'o' 'w' _)> */
		nil,
		/* 30 AM <- <('a' 'm' _)> */
		nil,
		/* 31 PM <- <('p' 'm' _)> */
		nil,
		/* 32 AT <- <('a' 't' _)> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if buffer[position] != rune('a') {
					goto l217
				}
				position++
				if buffer[position] != rune('t') {
					goto l217
				}
				position++
				if !_rules[rule_]() {
					goto l217
				}
				add(ruleAT, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 33 NEXT <- <('n' 'e' 'x' 't' _)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('n') {
					goto l219
				}
				position++
				if buffer[position] != rune('e') {
					goto l219
				}
				position++
				if buffer[position] != rune('x') {
					goto l219
				}
				position++
				if buffer[position] != rune('t') {
					goto l219
				}
				position++
				if !_rules[rule_]() {
					goto l219
				}
				add(ruleNEXT, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 34 LAST <- <((('l' 'a' 's' 't') / ('p' 'a' 's' 't') / ('p' 'r' 'e' 'v' 'i' 'o' 'u' 's')) _)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				{
					position223, tokenIndex223 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l224
					}
					position++
					if buffer[position] != rune('a') {
						goto l224
					}
					position++
					if buffer[position] != rune('s') {
						goto l224
					}
					position++
					if buffer[position] != rune('t') {
						goto l224
					}
					position++
					goto l223
				l224:
					position, tokenIndex = position223, tokenIndex223
					if buffer[position] != rune('p') {
						goto l225
					}
					position++
					if buffer[position] != rune('a') {
						goto l225
					}
					position++
					if buffer[position] != rune('s') {
						goto l225
					}
					position++
					if buffer[position] != rune('t') {
						goto l225
					}
					position++
					goto l223
				l225:
					position, tokenIndex = position223, tokenIndex223
					if buffer[position] != rune('p') {
						goto l221
					}
					position++
					if buffer[position] != rune('r') {
						goto l221
					}
					position++
					if buffer[position] != rune('e') {
						goto l221
					}
					position++
					if buffer[position] != rune('v') {
						goto l221
					}
					position++
					if buffer[position] != rune('i') {
						goto l221
					}
					position++
					if buffer[position] != rune('o') {
						goto l221
					}
					position++
					if buffer[position] != rune('u') {
						goto l221
					}
					position++
					if buffer[position] != rune('s') {
						goto l221
					}
					position++
				}
			l223:
				if !_rules[rule_]() {
					goto l221
				}
				add(ruleLAST, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 35 _ <- <Whitespace*> */
		func() bool {
			{
				position227 := position
			l228:
				{
					position229, tokenIndex229 := position, tokenIndex
					{
						position230 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l229
								}
								position++
								break
							case ' ':
								if buffer[position] != rune(' ') {
									goto l229
								}
								position++
								break
							default:
								{
									position232 := position
									{
										position233, tokenIndex233 := position, tokenIndex
										if buffer[position] != rune('\r') {
											goto l234
										}
										position++
										if buffer[position] != rune('\n') {
											goto l234
										}
										position++
										goto l233
									l234:
										position, tokenIndex = position233, tokenIndex233
										if buffer[position] != rune('\n') {
											goto l235
										}
										position++
										goto l233
									l235:
										position, tokenIndex = position233, tokenIndex233
										if buffer[position] != rune('\r') {
											goto l229
										}
										position++
									}
								l233:
									add(ruleEOL, position232)
								}
								break
							}
						}

						add(ruleWhitespace, position230)
					}
					goto l228
				l229:
					position, tokenIndex = position229, tokenIndex229
				}
				add(rule_, position227)
			}
			return true
		},
		/* 36 Whitespace <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EOL))> */
		nil,
		/* 37 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		nil,
		/* 38 EOF <- <!.> */
		nil,
		/* 40 Action0 <- <{
		   p.t = truncateDay(p.t.AddDate(-p.number, 0, 0))
		 }> */
		nil,
		/* 41 Action1 <- <{
		   p.t = truncateDay(p.t.AddDate(p.number, 0, 0))
		 }> */
		nil,
		/* 42 Action2 <- <{
		   p.t = time.Date(p.t.Year() - 1, 1, 1, 0, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 43 Action3 <- <{
		   p.t = time.Date(p.t.Year() + 1, 1, 1, 0, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 44 Action4 <- <{
		   p.t = truncateDay(p.t.AddDate(0, -p.number, 0))
		 }> */
		nil,
		/* 45 Action5 <- <{
		   p.t = truncateDay(p.t.AddDate(0, p.number, 0))
		 }> */
		nil,
		/* 46 Action6 <- <{
		   p.t = prevMonth(p.t, p.month)
		 }> */
		nil,
		/* 47 Action7 <- <{
		   p.t = nextMonth(p.t, p.month)
		 }> */
		nil,
		/* 48 Action8 <- <{
		   if p.direction < 0 {
		     p.t = prevMonth(p.t, p.month)
		   } else {
		     p.t = nextMonth(p.t, p.month)
		   }
		 }> */
		nil,
		/* 49 Action9 <- <{
		   year, month, _ := p.t.Date()
		   p.t = time.Date(year, month, p.number, 0, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 50 Action10 <- <{
		   p.t = truncateDay(p.t)
		 }> */
		nil,
		/* 51 Action11 <- <{
		   p.t = truncateDay(p.t.Add(-day))
		 }> */
		nil,
		/* 52 Action12 <- <{
		   p.t = truncateDay(prevWeekday(p.t, p.weekday))
		 }> */
		nil,
		/* 53 Action13 <- <{
		   p.t = truncateDay(nextWeekday(p.t, p.weekday))
		 }> */
		nil,
		/* 54 Action14 <- <{
		   if p.direction < 0 {
		     p.t = truncateDay(prevWeekday(p.t, p.weekday))
		   } else {
		     p.t = truncateDay(nextWeekday(p.t, p.weekday))
		   }
		 }> */
		nil,
		/* 55 Action15 <- <{
		   p.t = p.t.Add(-time.Minute * time.Duration(p.number))
		 }> */
		nil,
		/* 56 Action16 <- <{
		   p.t = p.t.Add(p.withDirection(time.Minute) * time.Duration(p.number))
		 }> */
		nil,
		/* 57 Action17 <- <{
		   p.t = p.t.Add(-time.Hour * time.Duration(p.number))
		 }> */
		nil,
		/* 58 Action18 <- <{
		   p.t = p.t.Add(p.withDirection(time.Hour) * time.Duration(p.number))
		 }> */
		nil,
		/* 59 Action19 <- <{
		   p.t = truncateDay(p.t.Add(-day * time.Duration(p.number)))
		 }> */
		nil,
		/* 60 Action20 <- <{
		   p.t = truncateDay(p.t.Add(p.withDirection(day) * time.Duration(p.number)))
		 }> */
		nil,
		/* 61 Action21 <- <{
		   p.t = truncateDay(p.t.Add(-week * time.Duration(p.number)))
		 }> */
		nil,
		/* 62 Action22 <- <{
		   p.t = truncateDay(p.t.Add(p.withDirection(week) * time.Duration(p.number)))
		 }> */
		nil,
		/* 63 Action23 <- <{
		   year, month, day := p.t.Date()
		   p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 64 Action24 <- <{
		   year, month, day := p.t.Date()
		   p.t = time.Date(year, month, day, p.number + 12, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 65 Action25 <- <{
		   year, month, day := p.t.Date()
		   p.t = time.Date(year, month, day, p.number, 0, 0, 0, p.t.Location())
		 }> */
		nil,
		/* 66 Action26 <- <{
		   t := p.t
		   year, month, day := t.Date()
		   hour, _, _ := t.Clock()
		   p.t = time.Date(year, month, day, hour, p.number, 0, 0, t.Location())
		 }> */
		nil,
		/* 67 Action27 <- <{
		   t := p.t
		   year, month, day := t.Date()
		   hour, min, _ := t.Clock()
		   p.t = time.Date(year, month, day, hour, min, p.number, 0, t.Location())
		 }> */
		nil,
		nil,
		/* 69 Action28 <- <{ n, _ := strconv.Atoi(text); p.number = n }> */
		nil,
		/* 70 Action29 <- <{ p.number = 1 }> */
		nil,
		/* 71 Action30 <- <{ p.number = 2 }> */
		nil,
		/* 72 Action31 <- <{ p.number = 3 }> */
		nil,
		/* 73 Action32 <- <{ p.number = 4 }> */
		nil,
		/* 74 Action33 <- <{ p.number = 5 }> */
		nil,
		/* 75 Action34 <- <{ p.number = 6 }> */
		nil,
		/* 76 Action35 <- <{ p.number = 7 }> */
		nil,
		/* 77 Action36 <- <{ p.number = 8 }> */
		nil,
		/* 78 Action37 <- <{ p.number = 9 }> */
		nil,
		/* 79 Action38 <- <{ p.number = 10 }> */
		nil,
		/* 80 Action39 <- <{ p.weekday = time.Sunday }> */
		nil,
		/* 81 Action40 <- <{ p.weekday = time.Monday }> */
		nil,
		/* 82 Action41 <- <{ p.weekday = time.Tuesday }> */
		nil,
		/* 83 Action42 <- <{ p.weekday = time.Wednesday }> */
		nil,
		/* 84 Action43 <- <{ p.weekday = time.Thursday }> */
		nil,
		/* 85 Action44 <- <{ p.weekday = time.Friday }> */
		nil,
		/* 86 Action45 <- <{ p.weekday = time.Saturday }> */
		nil,
		/* 87 Action46 <- <{ p.month = time.January }> */
		nil,
		/* 88 Action47 <- <{ p.month = time.February }> */
		nil,
		/* 89 Action48 <- <{ p.month = time.March }> */
		nil,
		/* 90 Action49 <- <{ p.month = time.April }> */
		nil,
		/* 91 Action50 <- <{ p.month = time.May }> */
		nil,
		/* 92 Action51 <- <{ p.month = time.June }> */
		nil,
		/* 93 Action52 <- <{ p.month = time.July }> */
		nil,
		/* 94 Action53 <- <{ p.month = time.August }> */
		nil,
		/* 95 Action54 <- <{ p.month = time.September }> */
		nil,
		/* 96 Action55 <- <{ p.month = time.October }> */
		nil,
		/* 97 Action56 <- <{ p.month = time.November }> */
		nil,
		/* 98 Action57 <- <{ p.month = time.December }> */
		nil,
	}
	p.rules = _rules
	return nil
}
